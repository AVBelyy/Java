// Программирование по контракту
// Тройки Хоара (доказательства)

// Примеры
public class L02 {
    long zzz(long a, long b) {
        // zzz(2, 2) = 4
        // zzz(2, -2) = 4 - incorrect input
        //
        // 1. Предусловие
        //      b >= 0
        //
        // 2. Постусловие
        //      result == a^b

        // a', b' - исходные значения переменных
        long r = 1;
        // b >= 0 && r == 1
        // inv: r * a^b == a'^b'
        while(b != 0) {
            // r * a^b == a'^b' && b != 0
            if(b % 2 == 1) {
                // r * a^b == a'^b' - нечетно
                r *= a;
                b--;
                // r * a^b == a'^b' && b - четно
            } else {
                // r * a^b == a'^b' && b - четно
            }
            // r * a^b == a'^b' && b - четно
            a *= a;
            b /= 2;
            // r * a^b == a'^b'
        }
        // r * a^b == a'^b'
        // (b == 0)
        // r == a'^b' (ура)
        return r;
    }

    double _sqrt(double x) {
        // sqrt(x) = y
        // 1. Предусловие
        //      x >= 0
        //
        // 2. Постусловие
        //      y * y == x
        //      y * y >= 0
        //
        //  √: R+ -> R+
        return 0.0 / 0.0;
    }

    int[] _sort(int []x) {
        // 2. Постусловие
        //      y.length == x.length
        //      for_all i: count(i, x) == count(i, r)
        //              && a[i] <= a[i + 1]
        return null;
    }

    // 
    // Как доказывать функции? Выводить постусловие из предусловие, используя тело функции как док-во
    // Как нам проверять предусловие? assert(b >= 0), например
    //
    //
    // Тройка Хоара
    // <P, S, Q> => применение S к предусловию P дает (доказуемо) постусловие Q
    //
    // [<P1, S1, Q1>, <P2, S2, Q2>] = <P1, S, Q2> (нужно: Q1 => P2)
    //
    // 1) Ветвления
    //
    // if(C)
    //      <P1, S1, Q1>
    //  else
    //      <P2, S2, Q2>
    //  => <P, S, Q> ?
    //
    // Q1 => Q
    // Q2 => Q
    // Q1 | Q2 => Q
    //
    // abs(x):
    //      <x < 0; x = -x; x > 0>
    //      <x >= 0; x = x; x >= 0>
    // P & C => P1
    // P & !C => P2
    // P => P1 | P2
    //
    // 2) Циклы
    // <P; while(C) <P', S', Q'>; Q>
    // a) P & C => P'
    // b) Q' & C => P'
    // c) (P | Q') & !C => Q
    //
    // 1': (P | Q') & !C => Q
    // 2': (P | Q') & C => P'
    //
    // (P | Q') - инвариант цикла = I
    // I & C => P'
    // Q' => I
    // I & !C => Q
    // I & C => P'
    //
    // COQ, Adga prove theorems
    //
    //
    int a = 0;
    int increment(int b) {
        a += b;
        return a;
    }
    // Инвариант функции с состоянием: [a = a' + b'], a "сохраняется"
    // Группа функций с общим состоянием - объект класса
}
